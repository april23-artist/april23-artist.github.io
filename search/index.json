[{"content":"前言 Helm 可以將 K8s 資源文件 (Deployment、Service、ConfigMap 等) 應用程式打包為 Chart。 可以輕鬆安裝和管理 Chart，並且能夠執行升級、回滾、卸載等操作。Helm 減少了手動編寫和管理 K8s 資源的負擔。\n步驟 安裝 Helm 下載 Helm 後目錄會有 helm-v3.16.3-linux-amd64.tar.gz 文件。\nwget https://get.helm.sh/helm-v3.16.3-linux-amd64.tar.gz 解壓縮 helm-v3.16.3-linux-amd64.tar.gz 文件。\ntar -zxvf helm-v3.16.3-linux-amd64.tar.gz 進入 linux-amd64 目錄，將 linux-amd64 目錄底下的 helm 複製到 /usr/local/bin/。\ncd linux-amd64/ sudo cp helm /usr/local/bin/ 檢查安裝是否完成。\nhelm version 使用 helm create \u0026lt;chart-name\u0026gt; 新增 chart 新增 chart 會建立一個 \u0026lt;chart-name\u0026gt; 的資料夾。 helm create \u0026lt;chart_name\u0026gt; \u0026lt;chart_name\u0026gt;/ ├── Chart.yaml # Helm Chart 的元數據文件，包含了有關 Chart 的基本信息，例如名稱、版本、描述等。 ├── charts/ # 用來存放其他 Chart 的依賴包。當你在 Chart.yaml 中指定了依賴關係時，這些依賴會被下載並放到這個目錄中。 ├── templates/ # Kubernetes 資源的模板文件。 └── values.yaml # 定義了 Helm Chart 中的默認值，它是 Chart 的配置文件。 常用 helm 指令 helm install \u0026lt;chart_name\u0026gt; # 安裝 helm uninstall \u0026lt;chart_name\u0026gt; # 卸載 helm delete \u0026lt;chart_name\u0026gt; # 刪除 helm upgrade \u0026lt;chart_name\u0026gt; # 升級 helm history \u0026lt;chart_name\u0026gt; # 歷史紀錄 helm rollback \u0026lt;chart_name\u0026gt; \u0026lt;version\u0026gt; # 版本回滾 helm upgrade --install \u0026lt;chart_name\u0026gt; # 安裝或升級 # -n \u0026lt;namespace\u0026gt; namespace 配置 # --values \u0026lt;values\u0026gt;.yaml 該文件包含 Helm Chart 配置的默認值 # -f \u0026lt;overwrite-values\u0026gt;.yaml 讓你覆蓋默認的配置 helm upgrade --install \u0026lt;chart_name\u0026gt; -n \u0026lt;namespace\u0026gt; --values \u0026lt;values\u0026gt;.yaml -f \u0026lt;overwrite-values\u0026gt;.yaml 參考 helm ","date":"2024-12-27T00:00:00Z","permalink":"https://april23-artist.github.io/p/k8s-install-helm/","title":"在 Kubernetes Cluster 安裝 Helm"},{"content":"前言 NFS (Network File System) 是一種共享文件系統，它允許不同的主機或容器之間共享文件或資料夾。 NFS 是一種網路檔案系統協定，可以讓多個容器和 Pod 在不同的節點上訪問同一份數據，這對於需要跨多個 Pod 或節點持久儲存數據的應用非常有用。\n步驟 每個 node 都需要安裝。\n安裝 NFS 客戶端工具 (nfs-common) # 更新包列表 sudo apt update # 安裝 NFS 客戶端工具 sudo apt install nfs-common 安裝 NFS 伺服器工具 (nfs-kernel-server) sudo apt install nfs-kernel-server 啟動 NFS 伺服器 sudo systemctl start nfs-kernel-server # 檢查 NFS 伺服器狀態 sudo systemctl status nfs-kernel-server # 檢查 NFS 客戶端，使用 showmount 命令查看 NFS 伺服器共享的目錄 showmount -e \u0026lt;nfs_server_ip\u0026gt; 選擇適合共享 nfs 目錄的 node (適合資料存儲的配置的 node) 進入 nfs server node，這邊選擇 /home/nfs/rw 作為共享目錄。\nsudo mkdir /home/nfs/rw 設置共享目錄。\n# 加上共享設定 # /home/nfs/rw \u0026lt;nfs_server_ip\u0026gt;.0.0/16(rw,sync,no_subtree_check,no_root_squash) sudo nano /etc/exports 重新加載。\nexportfs -f sudo systemctl reload nfs-server (補充) 將 nfs server node 共享目錄掛載到其他 node 的指定目錄裡 進入其他 node，選擇要同步共享目錄的資料夾。\nsudo mkdir -p /mnt/nfs/rw sudo mount -t nfs \u0026lt;nfs_server_ip\u0026gt;:/home/nfs/rw /mnt/nfs/rw # 取消掛載 sudo umount /mnt/nfs/rw ","date":"2024-12-27T00:00:00Z","permalink":"https://april23-artist.github.io/p/k8s-install-nfs/","title":"在 Kubernetes Cluster 安裝 Network File System"},{"content":"前言 Multipass 是輕量化的虛擬機管理工具，選擇搭配 k3s 而不選擇 minikube 是因為 k3s 可以建立多個 node，非常適合用來學習 k8s 的知識。\n步驟 安裝 Multipass choco install multipass 建立虛擬機 (nodes) 建立 3 個 node ，1 個 master，2 個 worker。\nmultipass launch --name k8s-master --cpus 1 --memory 4G --disk 10G multipass launch --name k8s-node1 --cpus 1 --memory 4G --disk 10G multipass launch --name k8s-node2 --cpus 1 --memory 4G --disk 10G 常用的 Multipass 指令。\nmultipass ls # 虛擬機列表 multipass start \u0026lt;node_name\u0026gt; # 啟動虛擬機 multipass stop \u0026lt;node_name\u0026gt; # 關閉虛擬機 multipass shell \u0026lt;node_name\u0026gt; # 進入虛擬機 multipass delete \u0026lt;node_name\u0026gt; # 刪除虛擬機 multipass purge # 清除已刪除虛擬機 在 master node 建立 k3s # 安裝 k3s curl -sfL https://get.k3s.io | sh - # 查看 k3s 配置文件 cat /etc/rancher/k3s/k3s.yaml # 安裝後即可使用 kubectl 指令 sudo kubectl get nodes 將 worker nodes 加入 master 叢集 輸入 exit 指令離開 master node。\n# 取得 Token $TOKEN = multipass exec k8s-master -- cat /var/lib/rancher/k3s/server/node-token # 取得 IP $MASTER_IP = (multipass info k8s-master | Select-String \u0026#34;IPv4\u0026#34; | ForEach-Object { $_ -replace \u0026#39;IPv4:\\s*\u0026#39;, \u0026#39;\u0026#39; }).Trim() # 將 Token、IP 指定給 worker nodes。 For ($f = 1; $f -le 2; $f++) { multipass exec \u0026#34;k8s-node$f\u0026#34; -- bash -c \u0026#34;curl -sfL https://get.k3s.io | K3S_URL=\u0026#39;https://$($MASTER_IP):6443\u0026#39; K3S_TOKEN=\u0026#39;$TOKEN\u0026#39; sh -\u0026#34; } 建立 master 與 worker nodes 的 SSH 進入 master node 產生 SSH 密鑰。\n# 確認 master node 是否有 SSH 密鑰 cat ~/home/ubuntu~/.ssh/id_rsa.pub # 若沒有則產生 SSH 密鑰 ssh-keygen -t rsa -b 4096 # 取得 SSH 密鑰 cat ~/.ssh/id_rsa.pub worker nodes 調整 SSH 配置 每個 worker node 都要執行。\n# 檢查 SSH 服務是否開啟 systemctl status ssh 調整 SSH 配置。\n# 進入設定檔，確保以下設置未被註解 (即沒有 #)。 # PubkeyAuthentication yes # AuthorizedKeysFile .ssh/authorized_keys sudo nano /etc/ssh/sshd_config # 重新啟動 SSH 服務 sudo systemctl restart ssh # 將 master SSH 密鑰寫入授權金鑰 echo \u0026#34;master SSH 密鑰\u0026#34; \u0026gt;\u0026gt; ~/.ssh/authorized_keys 在 master node 執行。\n# 測試 SSH 是否有通 ssh \u0026lt;worker node_name\u0026gt; 將 master node 的 k3s.yaml 配置複製到 worker nodes 進入 master node 複製 k3s.yaml 到 worker nodes。\n# SSH 密鑰複製到 root 用戶 sudo cp ~/.ssh/id_rsa /root/.ssh/ sudo cp ~/.ssh/id_rsa.pub /root/.ssh/ # 設定權限 sudo chmod 600 /root/.ssh/id_rsa sudo chmod 644 /root/.ssh/id_rsa.pub # 複製 k3s.yaml 到worker nodes sudo scp /etc/rancher/k3s/k3s.yaml ubuntu@k8s-node1:/tmp/k3s.yaml 進入 worker nodes ，將 k3s.yaml 的 server 改為 master node 的 IP。\n# 檢查目錄是否存在 ls /etc/rancher/k3s/ # 建立 /etc/rancher/k3s/ 目錄 sudo mkdir -p /etc/rancher/k3s/ # 確保 /tmp/k3s.yaml 文件存在後移動文件 sudo mv /tmp/k3s.yaml /etc/rancher/k3s/k3s.yaml # 修改 server 變數 # server: https://\u0026lt;master_ip\u0026gt;:6443 sudo nano /etc/rancher/k3s/k3s.yaml 設定 worker nodes 的 KUBECONFIG 進入 worker node 添加 KUBECONFIG 環境變數。\n# 添加環境變數 # export KUBECONFIG=/etc/rancher/k3s/k3s.yaml nano ~/.bash_profile # 使變更生效 source ~/.bash_profile (補充) 若 master node IP 改變，則調整 worker nodes 的設定重新加入叢集 進入 worker nodes 編輯環境變數文件。\n# 修改 K3S_URL 變數 # K3S_URL=\u0026#39;https://\u0026lt;master_ip\u0026gt;:6443\u0026#39; sudo nano /etc/systemd/system/k3s-agent.service.env # 重新載入和重啟服務 sudo systemctl daemon-reload sudo systemctl restart k3s-agent 參考 Multipass k3s Kubernetes 1 小時入門 ","date":"2024-12-25T00:00:00Z","permalink":"https://april23-artist.github.io/p/multipass-k3s/","title":"Multipass 搭配 k3s 建立 Kubernetes Cluster"},{"content":"前言 想紀錄開發筆記，決定透過 GitHub Actions 自動化部署 Hugo 到 GitHub Pages。\n步驟 Windows 安裝 Hugo 安裝 Chocolatey ，使用管理員身分開啟 Windows Terminal。\nSet-ExecutionPolicy Bypass -Scope Process -Force; [System.Net.ServicePointManager]::SecurityProtocol = [System.Net.ServicePointManager]::SecurityProtocol -bor 3072; iex ((New-Object System.Net.WebClient).DownloadString(\u0026#39;https://community.chocolatey.org/install.ps1\u0026#39;)) 安裝 Hugo，並確認 Hugo 版本。\nchoco install hugo choco install hugo-extended hugo version 建立 GitHub Repository 建立名稱為 \u0026lt;user_name\u0026gt;.github.io 的 Repo 作為 Hugo 的專案。 這裡使用的 hugo theme 為 Stask，直接使用 hugo-theme-stack-stater 範例來修改。 將 hugo-theme-stack-stater 內的檔案放入 \u0026lt;user_name\u0026gt;.github.io。\ngit clone https://github.com/CaiJimmy/hugo-theme-stack-starter.git hugo-theme-stack-starter 因為環境未安裝 Go 在執行 hugo build 時會出錯，所以要稍微調整。 範例專案沒有 theme，需下載 hugo-theme-stack。\ngit clone https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack 將專案內 go.mod, go.sum 刪除。 並調整 config \u0026gt; _default \u0026gt; module.toml。\n- path = \u0026#34;github.com/CaiJimmy/hugo-theme-stack/v3\u0026#34; + path = \u0026#34;hugo-theme-stack\u0026#34; 建置並啟動網站，若成功啟動網站即可將專案 push 到 GitHub。\nhugo build hugo server --disableFastRender 設定 GitHub Pages 新增分支 gh-pages。 Settings \u0026gt; (Code and automation) Pages \u0026gt; (Build and deployment) Branch 設定為分支 gh-pages/(root)。\n設定 Workflow 在分支 main 將範例原本的 .github\\workflows\\deploy.yaml 內容替換，並 push 到 GitHub ，將會自動化部署到 gh-pages 分支。\nname: Deploy Hugo site to GitHub Pages # 設定在 `push` 事件觸發時運行工作流。你可以根據需求修改觸發條件。 on: push: branches: - main # 當推送到 main 分支時觸發 # 定義工作流程的各個步驟 jobs: deploy: runs-on: ubuntu-latest # 使用最新版本的 Ubuntu 運行此工作流 steps: # 1. Checkout repository (將代碼庫檢出到 runner) - name: Checkout code uses: actions/checkout@v3 # 2. 設置 Hugo 環境 - name: Set up Hugo uses: peaceiris/actions-hugo@v2 with: hugo-version: latest extended: true # 3. 安裝 Hugo 主題 - name: Install Hugo theme run: | git clone https://github.com/CaiJimmy/hugo-theme-stack.git themes/hugo-theme-stack # 4. 建構 Hugo 網站 - name: Build the site working-directory: ./ run: hugo --minify --gc --cleanDestinationDir # 5. 部署到 GitHub Pages (gh-pages 分支) - name: Deploy to GitHub Pages uses: JamesIves/github-pages-deploy-action@v4 with: branch: gh-pages # 部署到 gh-pages 分支 folder: public # Hugo 網站的輸出目錄 clean: true # 部署之前清理已有的文件 參考 Stack 在 Windows 中安裝 Hugo ","date":"2024-12-24T00:00:00Z","permalink":"https://april23-artist.github.io/p/deploy-hugo-to-github-pages/","title":"透過 GitHub Actions 自動化部署 Hugo 到 GitHub Pages"}]